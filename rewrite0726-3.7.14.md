# 3.7.15 Atomic Object

So in out demo class, we have the same code as before. We have single status object that you're sharing across many different threads. Over here we're creating 10 download threads, ecach thread downloads 10000 bytes. So, once we join with all this thread, and print the total bytes, we expect to see 100000 on the terminal. Take a look. we don't see that. So, we have a race condition. Now, to solve this problem
So, here we are not using synchronization, we are not using locks, we have a very simple class. Now, to solve this problem, we need to change the type of this field from int to AnomicInteger, and we set this to a new AtomicInteger. Now, in our getter, we should return tutal bytes that get this will return the actual manusl. 

# 3.7.16 Adders

So atomic object are great for implementing counters. But if you have multiple threads updating a value frequently, it's better to use one of the other classed in Java. They're faster than atomic types. So we have LongAdder for adding long values and DoubleAdder. Let me show you how they work. So we have the code as before. This is the code that has a race condition.
Internally, this LongAdder object keeps an array of counter that can grow on demand. So we don't have a single place in memory where our value is stored. You have a bunch of array cells, each holding a counter value. So different threads can modify this counter variables concurrently. That's why these Adder classes are faster than atomic types, because they allow more throughput. So here we can call the intValue method. But internally, this method is going to call another method called sum(), which is going to add up all this counter values and return the result. The intValue() will call this method and then convert the result to an integer. Now in our increment method, we call increment, we also have `add` for adding a long value. We have **decrement()**, we have **reset()** and so on. So let's call the **increment()** method. That's all we have to do. Let's run our program. The race condition has gone.
So, if we have multiple threads updating a value frequently preferred the outer classes to atomic types.

# 3.7.17 Synchronized Collections

Sometimes we need to share a collection across many threads. So, let's create the collection object. So, new ArrayList internally, our objects are stored inside this ArrayList. But when we call this method, this method is going to run the **ArrayList** inside the **synchronizedCollection**. In that **synchronizedCollection**, all the method like `add()`, `remove() ` and so on. They have synchronization code. So **synchronous collection** essentially wraps a regular collection like an **ArrayList**. But it makes it synchronized. Now, with this simple change, when we run our program, we can see that 2 threads modify our collection concurrently. So this is how we can create a **synchronous collection**.

# 3.7.18 Concurrent Collections
Synchronous collections achieve thread safety by using locks. So when a thread gets access to a synchronous collection, the entire collection gets locked and other thread have to wait. This works well for mosts cases, but it can have a negative impact on the performance and scalability as the number of threads and concurrent operations increase. In those situations, we can use concurrent collections in Java. These classes use the partitioning technique to allow concurrency. So they divide their data into segments and different threads can concurrently work with different segments, but only one thread at a time can access a given segment. So **concurrent collections** are faster than **synchronous collections**. Because they don't use synchronization. These classes are declared in the `java.concurrent.package`. For example, we have **ConcurrentHashMap**, we have **ConcurrentLinkedDeque**, which is a double ended queue implementted using a linkless. We have **ConcurrentMap** and so on. So, let's take a look at an example. If we want to create a regular hashmap, we write `Map<Integer, String>`, we call it map and set it to `new HashMap<>()`. This is the regular hash map where our keys are integers, and our values are strings. Here we can call `map.put()` to add an entry like 1 and a. We can cal **map.get()** to get the value associated with a key, we can call **map.remove()** and so on. This is a regular HashMap implementation that is not thread safe. So if it's going to get accessed only by a single thread, it's perfectly fine. But if you want to share this across many different threads, we're going to have problems. Now to solve this, all we have to do is to replace the **HashMap** with **ConcurrentHashMap**. That's all we have to do. Everything else in our code stays the same, becasue this map is an interface. **HashMap** and **ConcurrentHashMap** are 2 different implementations of this interface. So by programming against interfaces, we reduce the impact of changes in our applications. We simply substitute one implementation with another. Everything else stays the same. Again, I cannot emphasize the importance of interfaces enough. A lot of developers don't understand the interfaces. They think they do, but honestly they don't. So, if you want to have a better understanding of interfaces and their power, watch the second part of this series. It will change how you think about building software.

# 3.8.1

So java5 introduced higher level abstractions that simplify building concurrent applications. What is abstractions? We don't need to explicitly work with threads. Instead, you focus on our tasks and let Java take care of thread manipulation. So in this section we'll be talking about **Thread Pools**, **Executors**, **Callable and Future interfaces**, and **Asynchronous Programming** with **Completable Futures**. So let's jumping and get started.

# 3.8.2 Thread Pools

Threads are the fundamental building blocks of concurrent applications. But working directly with threads has a couple of problems. The first problem is that we have a limited number of threads available to us. So, if you're not careful, you may end up creating too many threads and get out of memory exceptions. So, application will crash. The other issue is that crearing and destroying thread is costly. If you have 1000 tasks to execute, like 1000 images to download, and only 10 threads available, we have to download 10 images using this thread, then once these threads are complete, we have to create another set of 10 threads. And we have repeat this several times to execute all our tasks. Creating and destroying threads is expensive. So java5 came up with a solution called a **thread pool**. And thread pool is essentially a pool threads called **Worker Thread**. And this thread can be reused to execute several tasks. When a **work thread** finished, it return back to the pool, so it can be reused to execute another task. So these threads are not destroyed and recreated, they are always available and reused to execute many tasks. Also, because the thread will has a fixed number of threads, we don't have to worry about creating too many threads and running out of memory. For example, we can create a thread pool with 10 threads and submit 1000 tasks thread. The thread pool will take care of assigning our task to this thread. If all threads are busy, the new tasks will wait in a queue. As soon as the thread becomes available, it will pick up a task from the queue and execute it. So with this model, we don't have to think about creating thread directly. Instead, we submit our tasks to a thread pool and let the thread pool take care of thread manipulation. I'll show you how to that next.

# 3.8.3

In java, the concept of a thread pool is represented using the execute a service interface and its implementations. So, we have **ThreadPoolExecutor** which is a typical thread pool implementation. This is the one we use most of the time. We also have **ScheduledThreadPoolExecutro**, with this we can schedule tasks to run after a delay or periodicaly. For example, we can schedule a task to run five hours from now, or every 2 hours. We also have **ForkJoinPool**, this is a special type of pool that is designed to recursively split a task into smaller tasks ,and then combine the result of each subtask to produce the  overall result. It's like a divide and conquer algorithm. Let me show you how to create thread pool.
```java
var executor = Executors.newFixedThreadPool(2);
```
So, we are dealing with an interface here. At runtime, the type of this object is going to be **ThreadPoolExecutor**. Let me show you. So, if you print **executor.getClass().getName()**, then run the program. We see ThreadPoolExecutor. That is a thread pool with a number of worker threads. So, we have an executor, now, we can call **executor.submit()** to submit task to this thread pool. Now, this method is overloaded. We can pass a runnable object, we can also pass a callable that is a task returns result. We'll look at that later. So, for now, let's pass of runnable object here. I'm going to use a lambda expression. So here, let's print the name of the current thread. Now, technically we don't need the braces here, because we have a single print line statement. But i've got to keep them here for clarity, because I don't want to put this line over here. Otherwise, it's going to pop out on the screen. So, that's all we have to do to run a task on a separate thread. If we run this program, you can see our task was executer on this thread pool one, thread one.
So we didn't have to explicitly create a thread. But if you have 1000 tasks, we don't have to worry about creating too many threads and running out of memory. We simply submit those tasks that is executer through this thread pool. And this pool will assign our tasks to work thread. let me show you. So here we have a pool with two threads. Let's add a for loop. Now, with each iteration we submit a task to this pool, so we have only two threads available, but we're submitting 10 tasks. let's see what happens. Take a look. So some tasks are being execute on thread one, other tasks are being execute on thread two. see, so internally this executor maitains a queue, every task that was submitted, goes in this queue, and waits for available thread. Okay, now, let's get rid of this for loop. We don't need it anymore.