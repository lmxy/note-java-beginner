# 3.8.4

Sometimes we will return a value from a task. For example, we may call the twitter API to get the latest tweets for a given user. That's when we use the callable interface. If you look at the signature of the `submit()` method, you can see this method is overloaded. So far, we've been passing a runnable object to this method. But we can also pass a **Callable** object. This `Callable<V>` is an interface, very similar to the runnable interface. But this interface represents a task that returns a value. So if you scroll down, you can see this method has a single abstract method called `call()`. This is similar to the `run()` method of the `Runnable` interface. But instead of returning void, it returns `V` where `V` is the generic type parameter here. So, if we return a value in the body of this lambda, now this lambda matches a method with no parameters that returns a value. That is a `call()` method here. So this lambda expression that we have passed here represents a `Callable` object. Now we store the result in a variable called `future`. Let's look at the type of this variable, that is a `Future<Integer>`. This `Future` is an interface that represents the future result of an operation. An operation that will complete in the future, it may complete in 500 milliseconds or 2s or 5s, sometimes in the future. So the result of this operation is not going to be calculated immediately using the CPU. So with this `Future` object, we can get the future result of an operation. Okayy? Now, to make this demo more interesting, let's simulate a long running operation. So, in this package, the executors pakage, I'm gonna add a new class called `LongTask`. In this class we are gonna add a public static method `simulate()`. And here we'll put the thread to sleep for three seconds. So `Thread.sleep(3000)`. Now let's handle the **InterruptedException**. Now, back to ou **Demo** class, in this task, instead of printing the name of the current thread, I'm gonna call `LongTask.simulate()`. So, we're simulating a operation that's gonna take 3 seconds. Let's say we're gonna to call the **Twitter API** to get the latest **tweets** for user.
But eventually, this task will return a value in this case one. Now, let me call the `submit()` method, the `submit()` method is gonna return immediately. So it's not gonna wait for 3 seconds. It's gonna immediately return a **Future** object. With this `Future` object we can get the result of this operation. So this object has a bunch of useful methods, `get()` we can use use this to get the value of this operation, that `get()` is overloaded. With this operation, we can pass a . So, if the operation is gonna take so long, perhaps we don't want to wait forever. We want a timeout in, let's say 2 seconds. We can also call the `get()` method without a timeout value. We have `cancel()` for cancelling an operation. We have `isCancelled()`, with this we can check to see if an operation is cancelled, and `isdone()` which tells us if this operation is complete or not. So, I told you this submit method is gonna return immediately. So, here we can do some work, let's say `Do more work`. And at some point, you really need the result of the operation. That is when we call the `get()` method. Now, this method is going to block the current thread and having to wait until the result of the operation is ready. Eventually, it's gonna return a value. In this case, it's gonna return an integer, because our task returns an integer. So, let's store the result over here. Take a look, type of this variable is integer, Okay? Here we need to handle a couple of exceptions, one of them is `InterrupedExeception` that you have seen before. The other is `ExecutionException`, this happens if this task throws an exception. So, it can catch this exception over here and do something with it. And in this demo, I'm gonna simplify this code and combine this cache blocks. So vertical bar `ExecutionException`. Now, let's get rid of the second catch block. So, when I run this program, you will see that we immediately see this message on a terminal, because the `submit()` method is not gonna wait for the completion of this task. It's gonna start this task on a separate thread, and eventually when we call `future.get()`, we have to wait for this operation to complete. Now we get the result and print it. Let's see what happens. So, we see `Do more work`. Now, one two three seconds later, the result is ready. And we will print it over here.


the **shutdown()** method doesn't stop the current tasks. So it will for the completion of those tasks, but it's not going to accept any new task. In contrast, if you call **shutdownNow()** it will farce the existing tasks to stop. Okay? So, let's call the **shotdown()**. Now we run the program, we get this dialog box because we didn't shut down our executor previously. So, let's rerun this program. Alright, our program shutdown. So, if i run it again, we don't get that warning. Okay? Now, what if something goes wrong over here, or you maight have some code and this this code throws an exeception. With that, we're not going able to shut down executro properly. So, as a best practice, we should run this inside a try finally block. So, I'm going to try block here, in the try block we submit our task, and in the finally block, we shut down the executor. With this will make sure that no matter what we always shut down on executor and release it from the memory. So, this is the benefit of using the executor framework. We don't have to worry about thread manipulation anymore. We let Java, we let the executor framework take care of all of that. But you have to remember, even we use the executor framework, we still have to work about the concurrency problems. So if two tasks modify an object concurrently, we're going run into issues. So the executor of framework does not protect us from the concurrency problems we talked about in the last section. It just simplies thread manipulation. 