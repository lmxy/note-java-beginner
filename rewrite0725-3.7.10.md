# 3.7.10 Confinement
Let's see how we can use confinement to prevent race conditions. So instead of showing a single status object across multiple threads, you're going to have each thread work with its own status object. So, let's remove this global status object and remove from here as well. Now we're going to construct this class, and remove this parameter. And then set the status field to new DownloadStatus() object. Now, back to our demo class. So we start 10 threads, we wait for them to finish. At the end, you have to ask each thread for its status object, that will combine the total bytes across all these status object. But there's a problem here, recreating our download tasks over here. So later on, we won't have access to them. Now to solve this, we're going to create a list of DownloadFileTask objects, and every time you create a new DownloadFileTask, we're going to add it to that list. So let's create a list of DownloadFileTask we call it tasks, and set it to new ArrayList. Now in our for loop, first we create a task object, new DownloadFileTaskï¼Œthen we add it to our list, so tasks.add(task). And now we can pass that object over here. That's better. Now, after all these threads finished, we need to combine the total bytes across these tasks. So we go back to our DownloadFileTask class and create a getter for this field, so we can read it later on. We should return the status this field.
Now, as a best practice, move these getters and setters down to bottom. This makes our code cleaner and easier to read. So first we list our fields then we have a constructors, then we have our public method. And finally we have our getters and setters. So, let's move this down. There you go. So, after the run method we have a getter. Now, back to our demo class, here we can use the stream API to combine the total bytes across these tasks. So, we go to our tasks list, get its stream, then map each task to the total bytes it has downloaded. 
With this we get a stream of integers. Now, we can reduce this integer. So we call a reduce, and pass an initial value and then a biniary operator. For example, `reduce(0, (a, b) -> a + b)` or `reduce(Integer::sum)`. With this, we get the total bytes. So, let's store it over here, and then print it on the terminal.

# 3.7.11 Locks
Another stratety for preventing race conditions and visibles problems is to prevent multiple threads from accessing an object at the same time. This is called synchronization. So we have to synchronize coordinate multiple threads trying to access an object. We do that using locks. So we put a lock on a block of our code. And the Java virtual machine will ensure that only one thread at a time can execute that block of code, which is called the critical section. In reality, our code is going to get executed sequentially. So we use concurrency. As a metaphor, think of a hotel room, only one guest at a time can be in that room. When one gets goes in, we lock the door. So others cannot enter. They have to wait untial that guest checks out. Using locks the code is pretty much the same. You have the same concept in databases as well. I talked about this in my ultimate sequel course. So, we have the same code as before. We're sharing a single object across many download tasks. If you run this program, we have a race condition because every time we see a different value. So multiple threads are racing to update totalBytes field. Now, let's see how we can use a lock to solve this problem. So back to our DownloadStatus class. We want to ensure that only one thread at a time can increment this field. So here we declare a private field of type Lock. This is the interface declared in the `java.util.concurrent` package. Lock ,we call it lock and set it to a  new `ReentrantLock` This is one of the implementations of the of the Lock Interface. Now in our increment method, before we increment this field, we call lock.lock. So we call the lock method to lock this lock object. I know it sounds weird, then we increment the totalBytes field. And finally we call lock.unlock(). So when a thread enters this method, it will lock this lock object. This is like a guest going to a hotel room and locking the door. Other guests or  other thread have to wait for this guest to come out. This is how locking works, then, as a best practice, we should excute this line in a finally block. Because if an exception is thrown, we don't want to keep this lock locked forever. Otherwise, no other thread can execute this code. And this may cause a deadlock and our application will crash. So, let's add a try block here. When we execute the main logic inside the try block. If this causes an exception, with the finally block, we'll ensure that we always unlock this lock. That is this particular case, we don't really need to try finally block, because incrementing this field is not going to throw an exception. But in your applications, you maight have more complex logic and somewhere along this ligic, you maight get an exeception. So, make sure to unlock this lock inside a finally block. Now, let's run our program and see the result. So we get 100,000. let's try one more time. There you go. So, this is how we can use lock to prevent concurrency problems.

# 3.7.12 The synchronised Keyword

So you learn how to use locks to implement synchornization. Now, in Java we have another tool for implementing synchronizaion.    
First I'm going to delete the code that we wrote in the last video. We also don't need this lock object anymore. So  