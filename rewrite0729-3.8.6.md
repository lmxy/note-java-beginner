# 3.8.3
Take a look, this constructor has a buntch of parameters like **corePoolSize**, **maximumPoolSize** and so on. So create an executor explicity is a little bit difficult. That is why we use the facntory method on the executor class. So here we can call **newSingleThreadExecutor**, this returns an executor with a single thread. That'a something we used that often. We also have **newFixedThreadPool**, it will create a thread pool with a given number of worker threads. So that will be an instance of the **ThreadPoolExecutor** class. We also have **newScheduledThreadPool**, this will return an instance of this result. **ScheduledThreadPoolExecutor**. Okay? So, let's call **newFixedThreadPool()** with 2 work thread. Now we will store the resule in a variable called `executor`. Now, look at the type of this variable. So, we are dealing with an interface here. At runtime, the type of this object is going to be `ThreadPoolExecutor`. Let me show you, so, if you print `executor.getClass().getName()`. And run the program, we see `ThreadPoolExecutor`. That is a thread pool with a number of worker threads. Now, we can call `executor.submit()` to submit task to this thread pool. Now this method is overloaded, we can a `Runnable` object, we can also pass a `Callable` that is a task that returns a result. We'll look at that later. So, For now, we pass a `runnable` object here. I'm gonna use lambda expression. So here let's print the name of current thread. So, `Thread.currentThread().getName()`. Now technically we don't need the braces here, because we have a single print line statement. But I'm gonna keep them here for clarity, cause  I don't want to put this line over here. Otherwise, it's going to pop out of the screen. So, that's all we have to do to run a task on a separate thread. If you run the program, you can see our task was executed on this thread `pool-1-thread-1`. We didn't have to explicity create a thread. Now, if we have 1000 tasks, we don't have to worry about creating too many threads and running out of memory. We simply submit those tasks that is executor through the thread pool, and this pool will assign our tasks to worker thread. Let me show you. So here we have a pool with 2 threads, let's add a for loop 
```java
for (var i = 0; i < 10; i++)
  executor.submit(() -> {
    System.out.println(Thread.currentThread().getName());
  });
```
Now, in each iteration we submit a task to this pool, so we have only 2 threads available, but we're submitting 10 tasks. Let's see what happened. Take a look. So, some tasks are being executor on thread one, other tasks are being execute on thread two. So, intrernally this executor maintains a queue, every task we submitted, goes in this queue, and waits for an available thread. Okay? Now, let's get rid of this for loop. We don't need it any more, so we create an executor and submit a task. Now, if we run this program again, we get the dialong box saying our program is still running. Why is that? Because when we're trying to execute and submit a task, the executor thinks there might me more tasks coming in the future. So it's not gonna terminate, it's gonna stay in memory waiting for new tasks. So we have wo explicitly shut down the executor, terminate our program. To do that we call `executor.shutdown()`, we also have `shutdownNow()`. The difference is that the `shutdown()` method doesn't stop the current tasks. So it will wait for the completion of those tasks, but it's not gonna accept any new tasks. In contrast, if you you call `shutdownNow`, this will force the existing tasks to stop. Okay? So, let's call the `shutdown()` method. Now we run the program, we get the dialog box because we didn't shut down our executor previously. So, let's rerun this program, Right, our program shut down. So, if we run it again, we don't get that warning. Okay? Now, what if something goes wrong over here, or you might have some code and this code throws an exeception. With that, we're not gonna be able to shut down an executor properly. So, sa a best practice, we should run this inside a try finally blocl. So I'm gonna to add a try block here, and the try block was submit our task. And in the finally block, we shut down the executor with this we make sure that no matter what we will always shut down an executor and release it from the memory. So this is the benefit of using the executor framework. We don't have to worry about thread manipulation anymore. We let java, we let the executor framework take care of all of that. But you have to remember, even you when using the executor framework, we still have to worry about the concurrency problems. So if two tasks modify an object concurrently, we're gonna run into issues. So the executor framework does not protect us from the concurrencey problems we talked about in the last section. It just simplifies thread manipulation.