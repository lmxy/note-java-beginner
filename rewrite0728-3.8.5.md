# 3.8.3
Take a look, this constructor has a buntch of parameters like **corePoolSize**, **maximumPoolSize** and so on. So create an executor explicity is a little bit difficult. That is why we use the facntory method on the executor class. So here we can call **newSingleThreadExecutor**, this returns an executor with a single thread. That'a something we used that often. We also have **newFixedThreadPool**, it will create a thread pool with a given number of worker threads. So that will be an instance of the **ThreadPoolExecutor** class. We also have **newScheduledThreadPool**, this will return an instance of this result. **ScheduledThreadPoolExecutor**. Okay? So, let's call **newFixedThreadPool()** with 2 work thread. Now we will store the resule in a variable called `executor`. Now, look at the type of this variable. So, we are dealing with an interface here. At runtime, the type of this object is going to be `ThreadPoolExecutor`. Let me show you, so, if you print `executor.getClass().getName()`. And run the program, we see `ThreadPoolExecutor`. That is a thread pool with a number of worker threads. Now, we can call `executor.submit()` to submit task to this thread pool. Now this method is overloaded, we can a `Runnable` object, we can also pass a `Callable` that is a task that returns a result. We'll look at that later. So, for now, let's pass of runnable object here. I'm gonna use a lambda expression. So here, let's print the name of the current thread. because we have single print line statement. But I'm going to keep them here for clarity, cause  I don't want to put this line over here. Otherwise, it's going to popout our screen.



# 3.8.5

In the last video, I told you that get method is a blocking method, when we call it , the current thread has to wait until the result of this task is ready. So, even though you're executing this task in a seperate thread, we're making the current thread wait for the completion of that thread. We are not using our thread properly, we are wasting our thread. Then, this is a very simple application. This is a commandment application. But if you had a mobile or desktop app, this main thread would be responsible for handling the UI events such as mouse clicks and keystrokes. So, if we make the main thread wait for the completion of another thread, it's not going to be able to respond to UI events, that application will gone to freeze, and the user is not going to be able to resize or move it. So, to get the most out of our threads, we should write code in a non blocking way. And that is what we call asynchronous program.




In this class, we're going to add a public static method **simulate()**. And here we want to put the current thread to sleep for three second. So **thread.sleep(3000)**. Now let's handle the interrupted exception. Now back to our demo class, in this task, instead of printing the name of the current thread, I'm going to call **LongTask.simulate()**. So we're simulaing the operation, that's going to take 3 seconds. Let's say we're going to call the **Twitter API** to get the latest tweets for user. But eventually, this task is going to return a value in this case 1. Now, when we call a **submit()** method, the **submit()** method is going to return immediately. So, it's not going to wait for 3 seconds, it's going to immediately return a **future** object. With this **future** object, we can get the result of this operation. 