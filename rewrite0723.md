write code that can leverage these multi core processors. This makes your applications faster and more responsive. We'll start this section with a quick overview of key terms and concepts, such as processes and threads. We'll talk about starting, pausing and interrupting threads. Then we'll look at concurrency issues such as threads conditions and visibility problems. These are the issues that can exist in all concurrent system. They'are not specific to Java. So we look at this problems, and then I will show you various strategies to prevent them. Look at synchronization, volatile fails, atomic objects, and other types made for this purpose.
# Processes and Threads
Let's start this section with a quick overview of the key terms and ideas in concurrent systems. The one key term to understand is process. A process is an instance of a program or an application. When you launch an application like your code editor or music player, you're operating system loads that application inside a process. So process contains an image of applications code. It has some memory and a bunch of other resouces. Now your operating system can execute many processes at the same time. For example, it can run an antivirus while playing music. So that's concurrency at the process level, but we can also have concurrency within the process or within the application using threads. Technically speaking, a thread is a sequence of instructions. That's why it's called a thread. It's like a thread of instructions. Now, practically speaking, a thread is actually that thing that executes your code. Each process has at least one thread called the main thread, but we can create additional threads to run many tasks concurrently. For example, we can build a web server that can serve many clients at the same times, While server each client using a separate thread. Or we can build an application that downloads multiple images concurrently. We do this by starting multiple threads and have each thread download a separate image. This is what we call multi threading. Applications that use multiple threads are called multi threaded applications. Now, these days most processors have multiple cores. And this cores can be used for running many processes or threads. If your application doesn't use threads, is essentially using only one of the processor cores, so it's not utilizing the full power of your CPU, your hardware is wasted. let me show you. So I want to print thread.
# Interrupting a Thread
Quite often when dealing with long lives tasks, we want to give our users the ability to cacel. 
Instead of passing this read to simulate a long running task, let's add a for loop that continuously print a message on a terminal. So for i equals zero, as long as it's less than integer dot max value. I want a really large number. With this we can easily verify if our download actually gets candelled. Now, back to our demo class. I want to cancel this thread after one second. So let's pause the current thread for one second. That is thread sleep 1000. Just like before, we should handle the interrrupted exception here. So restarting a separate thread to download a file, and then have the current thread that is the main thread that is executing this code. Wait for one second. Now, to cancel the
In all the examples I've shown you so far, our download threads have been isolated from each other. But in a real rare scenario, sometimes our threats may need to access and modify shared resources. For example, when downloading files, each thread may report the number of bytes it has downloaded to a shared object. By this object, we can keep track of the entire downloas progress and report it to the user.Now, if multiple threads access the same object, and at least one of them changes this object, we're going to run into a couple of issues. The first issue happens when multiple threads try to modify the same data at the same time. It's like having one burger and three people wanting to eat it at the same time. It's not going to work.If multiple thread try to change the same data, we may get the wrong results or our application may crash. When this happens, we say we have a race condition, which means multiple threads are racing or competing to modify some data. I'll show you an example. This in the next video. Another issue happens when one thread changes the shirt data. But it changes are not visible to other threads. So different threads will have different views of the shared data. This is what we call a visibility problem. So if multiple threads access the same data, and at least one of them tries to change it, we are gonna to have some problems. If they only want to read the shirt data, that's perfectly fine. And by the way, this problems are not specific to Java. These are properties of concurrent systems, we have the same problem in databases because multiple users can modify the same data at the same time. It talked about this in my ultimate sequel course. So if you want to build a multi threaded application, you need to have a proper understanding of this problems and know how to prevent them. You should write code that can be safely executed by many threads in parallel. This is called Thread-safe Code. It's one of those terms that you see in the Java documentation a lot. Some classes are thread safe, which means they can be safely used across many parallel threads will talk about this later.